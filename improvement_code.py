# -*- coding: utf-8 -*-
"""improvement_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11xlc1zMV3HniaxS7vOEBmRdKaqzjGNDj
"""

import zipfile
import os

# Define the file path
zip_file_path = "/content/assignment.zip"
extract_folder = "/content/extract_folder"

# Extract the ZIP file
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_folder)

# List extracted files
extracted_files = os.listdir(extract_folder)
extracted_files

import tensorflow as tf
from tensorflow.keras import layers, Model
import matplotlib.pyplot as plt
import numpy as np
import os
import random
import cv2

# --- Data Loading and Preprocessing ---
def load_and_preprocess_data(show_examples=False, num_examples=5):
    """Loads and preprocesses MNIST dataset."""
    (train_images, train_labels), (test_images, test_labels) = tf.keras.datasets.mnist.load_data()

    # Normalize and reshape for Conv2D compatibility
    train_images = train_images.astype('float32') / 255.0
    train_images = train_images.reshape(-1, 28, 28, 1)
    test_images = test_images.astype('float32') / 255.0
    test_images = test_images.reshape(-1, 28, 28, 1)

    if show_examples:
        plt.figure(figsize=(10, 2))
        for i in range(num_examples):
            index = random.randint(0, len(train_images) - 1)
            plt.subplot(1, num_examples, i + 1)
            plt.imshow(train_images[index, :, :, 0], cmap='gray')
            plt.title(f"Label: {train_labels[index]}")
            plt.axis('off')
        plt.show()

    return (train_images, train_labels), (test_images, test_labels)

# --- SE Block for SE-CNN ---
def se_block(input_tensor, reduction=16):
    """Squeeze-and-Excitation block to enhance feature recalibration."""
    filters = input_tensor.shape[-1]
    se = layers.GlobalAveragePooling2D()(input_tensor)
    se = layers.Dense(filters // reduction, activation='relu')(se)
    se = layers.Dense(filters, activation='sigmoid')(se)
    se = layers.Reshape((1, 1, filters))(se)
    return layers.Multiply()([input_tensor, se])

# --- SE-CNN Model ---
def build_se_cnn(input_shape=(28, 28, 1)):
    """Builds an SE-CNN model for MNIST classification."""
    inputs = layers.Input(shape=input_shape)
    x = layers.Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
    x = se_block(x)
    x = layers.MaxPooling2D((2, 2))(x)
    x = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = se_block(x)
    x = layers.MaxPooling2D((2, 2))(x)
    x = layers.Conv2D(64, (3, 3), activation='relu', padding='same')(x)
    x = se_block(x)
    x = layers.Flatten()(x)
    x = layers.Dense(64, activation='relu')(x)
    outputs = layers.Dense(10, activation='softmax')(x)

    model = Model(inputs, outputs)
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    return model

# --- Training Function ---
def train_model(model, train_images, train_labels, epochs=20, batch_size=64, validation_split=0.1, callbacks=None):
    """Trains the model with given data."""
    history = model.fit(train_images, train_labels, epochs=epochs, batch_size=batch_size,
                        validation_split=validation_split, callbacks=callbacks)
    return history

# --- Evaluation Function ---
def evaluate_model(model, test_images, test_labels):
    """Evaluates the model on test data."""
    test_loss, test_acc = model.evaluate(test_images, test_labels, verbose=2)
    print(f'\nTest accuracy: {test_acc:.4f}')
    print(f'Test loss: {test_loss:.4f}')
    return test_loss, test_acc

# --- Visualization Functions ---
def predict_and_display(model, test_images, test_labels, num_predictions=5):
    """Displays predictions with probability bars."""
    predictions = model.predict(test_images)
    plt.figure(figsize=(10, 2 * num_predictions))
    for i in range(num_predictions):
        index = random.randint(0, len(test_images) - 1)
        predicted_label = np.argmax(predictions[index])
        true_label = test_labels[index]

        plt.subplot(num_predictions, 2, 2 * i + 1)
        plt.imshow(test_images[index, :, :, 0], cmap='gray')
        plt.title(f"True: {true_label}, Pred: {predicted_label}")
        plt.axis('off')

        plt.subplot(num_predictions, 2, 2 * i + 2)
        plt.bar(range(10), predictions[index])
        plt.xticks(range(10))
        plt.ylim([0, 1])
        plt.title("Probabilities")
    plt.tight_layout()
    plt.show()

def plot_training_history(history):
    """Plots training and validation accuracy/loss curves."""
    plt.figure(figsize=(12, 4))
    plt.subplot(1, 2, 1)
    plt.plot(history.history['accuracy'], label='Train')
    plt.plot(history.history['val_accuracy'], label='Validation')
    plt.title('Model Accuracy')
    plt.ylabel('Accuracy')
    plt.xlabel('Epoch')
    plt.legend(loc='upper left')

    plt.subplot(1, 2, 2)
    plt.plot(history.history['loss'], label='Train')
    plt.plot(history.history['val_loss'], label='Validation')
    plt.title('Model Loss')
    plt.ylabel('Loss')
    plt.xlabel('Epoch')
    plt.legend(loc='upper left')
    plt.tight_layout()
    plt.show()

# --- Model Saving and Loading ---
def save_model(model, filepath="se_cnn.keras"):
    """Saves the trained model."""
    model.save(filepath)
    print(f"Model saved to {filepath}")

def load_model_from_file(filepath="se_cnn.keras"):
    """Loads a saved model."""
    if os.path.exists(filepath):
        model = tf.keras.models.load_model(filepath, custom_objects={'se_block': se_block})
        print(f"Model loaded from {filepath}")
        return model
    print(f"Error: Model file not found at {filepath}")
    return None

# --- External Image Prediction ---
def load_and_preprocess_image(image_path, target_size=(28, 28)):
    """Preprocesses an external image for prediction."""
    try:
        img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        if img is None:
            print(f"Error: Could not read image at {image_path}")
            return None
        if np.mean(img) > 127:  # Invert if background is light
            img = 255 - img
        img = cv2.resize(img, target_size)
        img = img.astype('float32') / 255.0
        img = img.reshape((1, 28, 28, 1))
        return img
    except Exception as e:
        print(f"Error processing image {image_path}: {e}")
        return None

def predict_digit(model, image):
    """Predicts the digit from a preprocessed image."""
    prediction = model.predict(image)
    return np.argmax(prediction)

# --- Main Function ---
def main():
    """Executes the SE-CNN training and evaluation pipeline."""
    # Load and preprocess data
    (train_images, train_labels), (test_images, test_labels) = load_and_preprocess_data(show_examples=True)

    # Build or load SE-CNN model
    model_filepath = "se_cnn.keras"
    model = load_model_from_file(model_filepath)

    if model is None:
        model = build_se_cnn()
        model.summary()
        callbacks = [
            tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=3, restore_best_weights=True),
            tf.keras.callbacks.ModelCheckpoint(model_filepath, monitor='val_loss', save_best_only=True)
        ]
        history = train_model(model, train_images, train_labels, callbacks=callbacks)
        plot_training_history(history)
        save_model(model, model_filepath)
    else:
        print("Using pre-trained model.")

    # Evaluate on test data
    evaluate_model(model, test_images, test_labels)

    # Visualize predictions
    predict_and_display(model, test_images, test_labels)

    # Predict on an external image (example path)
    image_path = '/content/image_file'  # Update this path as needed
    image = load_and_preprocess_image(image_path)
    if image is not None:
        digit = predict_digit(model, image)
        print(f"Predicted digit from external image: {digit}")

if __name__ == "__main__":
    main()

import tensorflow as tf
from tensorflow.keras import layers, Model
import numpy as np
import cv2
import os

# --- SE Block Definition (Required for Loading Model) ---
def se_block(input_tensor, reduction=16):
    """Squeeze-and-Excitation block to enhance feature recalibration."""
    filters = input_tensor.shape[-1]
    se = layers.GlobalAveragePooling2D()(input_tensor)
    se = layers.Dense(filters // reduction, activation='relu')(se)
    se = layers.Dense(filters, activation='sigmoid')(se)
    se = layers.Reshape((1, 1, filters))(se)
    return layers.Multiply()([input_tensor, se])

# --- Model Loading ---
def load_model_from_file(filepath="se_cnn.keras"):
    """Loads a saved SE-CNN model."""
    if os.path.exists(filepath):
        model = tf.keras.models.load_model(filepath, custom_objects={'se_block': se_block})
        print(f"Model loaded from {filepath}")
        return model
    print(f"Error: Model file not found at {filepath}")
    return None

# --- External Image Preprocessing ---
def load_and_preprocess_image(image_path, target_size=(28, 28)):
    """Preprocesses an external image for prediction."""
    try:
        img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        if img is None:
            print(f"Error: Could not read image at {image_path}")
            return None
        if np.mean(img) > 127:  # Invert if background is light
            img = 255 - img
        img = cv2.resize(img, target_size)
        img = img.astype('float32') / 255.0
        img = img.reshape((1, 28, 28, 1))
        return img
    except Exception as e:
        print(f"Error processing image {image_path}: {e}")
        return None

# --- Digit Prediction ---
def predict_digit(model, image):
    """Predicts the digit from a preprocessed image."""
    prediction = model.predict(image)
    predicted_digit = np.argmax(prediction)
    probabilities = prediction[0]
    return predicted_digit, probabilities

# --- Main Function ---
def main():
    """Loads the SE-CNN model and predicts digits from an external image."""
    # Model path
    model_filepath = 'se_cnn.keras'  # Ensure this matches the saved model from training

    # Load the trained model
    model = load_model_from_file(model_filepath)
    if model is None:
        print("Exiting due to model loading failure.")
        return

    # Specify the image path (update this as needed)
    image_path = '/content/Hand_written_7.webp'  # Example path; replace with your image path

    # Preprocess the image
    image = load_and_preprocess_image(image_path)
    if image is None:
        print("Exiting due to image loading failure.")
        return

    # Predict the digit
    predicted_digit, probabilities = predict_digit(model, image)
    print(f"Predicted digit: {predicted_digit}")
    print(f"Prediction probabilities: {probabilities}")

    # Optional: Display probabilities (can be visualized if matplotlib is added)
    print("Class probabilities:")
    for i, prob in enumerate(probabilities):
        print(f"Digit {i}: {prob:.4f}")

if __name__ == "__main__":
    main()